#

*ver.0.4 10.04.2023*

- в конструкторе класса `Army` прописана логика выбора типа юнита для добавления:
```
Position pos = Field.nextPosition(side);
int nextUnit;
if (side) nextUnit = r.nextInt(4);
else nextUnit = r.nextInt(10,14);
```
Селектором выступает булева переменная `side`, и свичем выбирается тип юнита, дефолтное
значение - крестьянин (в нашем случае - при выпадении 0 или 10).  
Таким образом есть потенциал для расширения количества боевых классов, а так же,
если заменить булеву переменную на число, то и несколько композиций армии можно продумать.  
Но идеальный вариант другой - в процентном соотношении задавать количество юнитов
каждого типа в армии. Может в будущем сделаю, если интерес останется.
- так же в `Army` добавил статическое поле `priorityList` для хранения списка юнитов из
всех армий, и статические методы для заполнения этого поля и сортировки в соответветствии
с инициативой юнита. Отсюда можно пойти простым путём и использовать их ровно по одному
разу, либо (это уже было запланировано ранее) вызывать сортировку перед каждым ходом.
Так как у юнитов предполагаются специальные действия по изменению параметра инициативы:
(например, снайпер может прицелиться - увеличение точности, уменьшение инициативы)
- Собственно добавлены эти методы, спешл-атаки или спешл-действия. Пока решил, что
вероятность совершения юнитом спешла будет 1/3. Посмотрим, может в дальнейшем логику
какую-нибудь прикручу.
- добавлен в интерфейс метод `move(Position position)` - сделать шак в сторону указанной
позиции. Ходить будут все. 

Пример вывода в консоль отсортированного списка всех юнитов:
 ![Alt text](%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%20%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0%204.png)

 ![Alt text](%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%20%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0%204%202.png)
 
#

*ver.0.3 31.03.2023*

- рассортировал классы по пакетам
- переработал интерфейсы, теперь есть один родительский метод `action()`, всё гораздо
проще, чем я думал - просто в дочерних классах я могу из переопрёделённого метода
`action()` по любым условиям и проверкам вызывать любые свои методы. И, главное,
всё будет работать и для списка из родительского класса
- добавил методы `takeDamage()` в классе BaseUnit для получения урона (отрицательный урон = лчение) 
и `calculateDamage` в классе ArmyBaseHero для расчёта нанесённого урона с учётом всех 
множителей , точности нападающего и уклонения защищаюсегося.
- начал заполнение `action()` для пИхоты и владельцев маны 

#

*ver.0.2 31.03.2023*

Добавлен интерфейс в самый родительскй абстрактный класс. Были планы добавить интерфейс только воинам, 
но нет понимания, как быстро и удобно обращаться к методам потомков из ArrayList<BaseUnit>.  
Поэтому пока так..
Ну и в принципе бардак в голове -)  

Вторая версия иерархии юнитов:
![Иерархия юнитов](%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%8F%20%D1%8E%D0%BD%D0%B8%D1%82%D0%BE%D0%B2%202.png)

Пример вывода в консоль:
![Пример вывода в консоль](%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%20%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0%202.png)

#

*ver.0.1 29.03.2023*

Первое ДЗ по ООП

Первая версия иерархии юнитов:

![Иерархия юнитов](%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%8F%20%D1%8E%D0%BD%D0%B8%D1%82%D0%BE%D0%B2%201.png)

Пример вывода в консоль:

![Пример вывода в консоль](%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%20%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0%201.png)